---
title: 浏览器相关知识整理
date: 2019-07-21 19:48:32
tags: JavaScript
categories: 前端
---

整理了浏览器相关的一些知识，包括浏览器的组成、渲染引擎渲染机制等
<escape><!-- more --></escape>
### 浏览器结构组成
1. **用户界面**（除了页面显示窗口之外的其他部分）
2. **浏览器引擎**（负责通信，用户界面、渲染引擎之间传送指令，缓存中读写数据）
3. **渲染引擎**（解析 HTML 和 CSS 并渲染）
4. **网络**（网络调用或资源下载）
5. **UI 后端**（绘制基本的浏览器窗口内控件）
6. **JS解释器**（解释、编译、执行JS脚本）
7. **数据存储**（保存 cookie、localStorage 等各种数据）

### 渲染引擎的工作流程
1. **构建 DOM 树**
2. **解析 CSS 文件**，生成一个具有样式规则描述的 DOM 渲染树
3. **将渲染树进行布局、绘制**
4. 如渲染完首屏后，对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的**重新布局和重新绘制**
PS：CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配，是为了节省效率，但是也要尽量避免在选择器末尾添加通配符。

### 渲染引擎相关的性能优化
1. **减少 JS 加载对 Dom 渲染的影响**
2. **避免重排，减少重绘**（减少使用 width、 margin、 padding 等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替）
3. **减少使用关系型样式表的写法**（使用唯一的类名、避免在选择器末尾添加通配符）
4. **减少 DOM 的层级**

### 浏览器的渲染进程
1. **GUI渲染线程**（渲染浏览器界面，与JS引擎线程是互斥）
2. **JS引擎线程**（处理Javascript脚本程序，与GUI引擎线程是互斥）
3. **事件触发线程**（控制事件循环，待处理队列中的事件都得排队等待JS引擎处理）
4. **定时触发器线程**（setInterval与setTimeout所在线程，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
5. **异步http请求线程**（如有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行）
6. **浏览器重绘和重排**

### 几种主流内核
1. **Trident**（1997，IE，浏览器被弃用）
2. **Gecko**（2000，FireFox）、
3. **Webkit**（2001，Safari）
4. **Presto**（2003，opera前内核、已废弃）
5. **Chromium**（2008，Chrome前内核，基于webkit）
6. **blink**（2013，Chrome，Google 和 Opera Software 共同研发）
7. **EdgeHTML**（2015，Edge已重选Chromium作为内核）

### 浏览器重绘和重排
1. **重排**(reflow) - 节点尺寸位置发生改变，对性能影响更大，会影响到其父元素、子元素和兄弟元素的重排
2. **重绘**(repaint) - 背景颜色图片、外观属性等发生改变
文档初次加载时：浏览器引擎将**HTML文档解析成对应的DOM树**根据DOM元素的几何属性来**构建一个用于渲染的渲染树**，渲染树的每个节点都包含其大小和内外边距等属性（对于隐藏的不需要显示的元素，不会构建到渲染树当中）。渲染树构建完成后，浏览器就可以将元素放置到正确位置了，再根据渲染树节点的样式属性**绘制到页面**中。

**哪些改变能引起重排：**
1. 重新调整浏览器窗口大小
2. 添加、删除可见的DOM元素
3. 添加、删除样式表
4. 激活CSS伪类，如a:hover
5. 修改字体
6. 修改class的属性
7. 设置style的属性
8. 页面渲染器初始化
9. 计算offsetWidth和offsetHeight
10. display: none 隐藏一个 DOM 节点-触发重排和重绘
11. visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化

**如何避免重排或者减少重排带来的性能问题：**
1. 减少使用 width、 margin、 padding 等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替
2. 避免在内联样式中设置多重属性
3. 将动画应用在 absolute 定位或者 fixed 的元素上
4. 减少 table 布局
5. 批量修改 DOM
6. DOM离线化，即给元素设置display:none后进行操作不会频繁触发重排和重绘，只会在元素添加到元素中的时候触发一次
7. 缓存布局信息（将某个值缓存下来，避免重复读取）

### 浏览器的内存分配和垃圾回收

### 浏览器缓存（强缓存、协商缓存）
**当客户端请求某个资源时，获取缓存的流程如下：**
1. 先根据这个资源的一些`http header`判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器
2. 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源

**强缓存、协商缓存的异同：**
**共同点**：如果命中缓存，服务器都不会返回资源
**不同点**：强缓存不会发送请求到服务器，协商缓存会发送请求验证，当协商缓存没命中时，服务器就会将资源发送回客户端
PS:当`ctrl+f5`强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存，但是当`f5`刷新网页时，会跳过强缓存，但是会检查协商缓存

### 谷歌浏览器跨域
浏览器**图标**右键--**属性**--在**目标**后面加上` --disable-web-security --user-data-dir=C:\MyChromeDevUserData`
注意：最开始有一个空格

### 谷歌浏览器中快速截图
1. 打开开发者工具
2. `ctrl + shift + p`
3. 输入`full`

