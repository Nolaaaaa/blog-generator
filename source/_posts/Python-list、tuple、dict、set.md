---
title: Python--list、tuple、dict、set
date: 2019-04-18 18:04:16
tags: Python
categories: 后端
---

Python--list、tuple、dict、set
<escape><!-- more --></escape>
### list
创建：用 `[]` 创建
取值：**根据索引**，如 `L[0]` 取出索引为 0 的值；**切片**，如：`L[0:3]` 取出从索引 0-3 的值，其中不包括索引 3 的值
特点：**有序**集合。list **能修改**。**查找速度随元素的增加而变慢**。**内存占用小**
常用方法：
```py
# 比较两个列表元素
cmp(L1, L2)

# 生成列表
L = range(1,4)  # [1, 2, 3]

### 尾部添加元素
L.append(4)     # [1, 2, 3, 4]

### 指定位置添加元素
L.insert(2,66)  # [1, 2, 66, 3, 4] 第一个值是索引位置，第二个值是新元素

### 删除最后一个元素
L.pop()         # [1, 2, 66, 3]

### 删除指定位置元素
L.pop(2)        # [1, 2, 3]  传入的 2 是索引位置

### 计算表达式的长度
print(len(L))   # 3        

### list合并拼接
zip([1,2,3],['A','B','C'])   # [(1,'A'),(2,'B'),(3,'C')]
[1,2,3] + ['A','B','C']      # [1,2,3,'A','B','C']
[1,2,3]*2                    # [1, 2, 3, 1, 2, 3]

### 迭代中拿到索引（迭代取出的都是元素本身的值）
for index,value in enumerate(L):
  print(index, ':' , value)   # 0 : 1  1 : 2  2 : 3  使用enumerate(L)

for index,value in zip(range(0,3),L):
  print(index, ':' , value)   # 0 : 1  1 : 2  2 : 3  使用zip()拼接的方法
```

### tuple
创建：用 `()` 创建，`空元组`直接用 `()` 创建，`单个元素`的元素后加`,`，避免歧义，如 `(1,)`
取值：**根据索引**，如 `T[0]` 取出索引为 0 的值；**切片**，如：`T[0:3]` 取出从索引 0-3 的值，其中不包括索引 3 的值
特点：**有序**集合。**一旦创建不能修改**（每个元素的指向永远不变，但是如果指向的是一个list，list是可变的）。
常用方法：
```py
# 比较两个元组元素
cmp(T1, T2)

# 列表转换为元组
tuple(L)
```


### dict
创建：用 `{}` 创建，其值为 `{key: value}` 的形式，和JS中的 map、object 类似
取值：**根据 key**，如 `D[key]` 取出 key 的 value；**get方法**，如：`D.get[key]`
特点：**无序**集合（打印顺序和创建顺序可能不一样）。**查找速度快**。**内存占用大**。**key元素必须是不可变的**，所以不能是 list 。**key 不重复**
常用方法：
```py
# 以列表返回一个字典所有的键
D.keys()

# 迭代字典中的 value 
D.values()           # 把 value 转为 list
D.itervalues()       # 不转为 list，省内存

# 迭代字典中的 key 和 value  
D.items()           # 把 value 转为 list
D.iteritems()       # 不转为 list，省内存
```

### set
创建：用 `set()` 创建，中间是个 list，如：`set([1,2,3])`
取值：不能通过索引来访问值，但是可用 in 进行判断
特点：**无序**集合。**不包含重复元素**。**判断元素是否在set中很快**。**储存的元素是不可变对象**（可以用in判断但不能循环，可以新增和添加但不能修改）
常用方法：
```py
S = set([1,2,3])
# 添加元素
S.add(4)      # 如果已存在不会添加进去，但是也不会报错
# 添加元素
S.remove(4)   # KeyError: 4   如果不存在去，会报错，所以用之前要先判断元素是否存在
```