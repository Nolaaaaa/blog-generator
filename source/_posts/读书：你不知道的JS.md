---
title: 读书：你不知道的JS
date: 2019-08-31 20:44:10
tags: [JavaScript]
categories: 前端
---

【你不知道的JS】一共上中下三册，包含内容有：作用域和闭包、this和对象原型、类型和语法、异步和性能、ES6及更新版本等内容，整理本篇博客目的主要是整合所学基础知识
<escape><!-- more --></escape>

### 作用域和闭包
#### 引擎、编译器、作用域
**代码执行前的编译会经历的三个步骤：**
1. 词法分析：将字符组成的**字符串**分解成有意义的**代码块（词法单元）**，会有特定步骤进行性能优化
2. 语法分析：将**词法单元**转化成一个**抽象语法树（AST）**，会有特定步骤进行性能优化
3. 生成代码：将**AST**转化为**可执行代码**

**引擎、编译器、作用域的任务：**
1. 引擎：负责JS的编译、执行过程
2. 编译器：负责语法分析、代码生成
3. 作用域：收集维护变量、有一套严格的规则（如：词法作用域）

**当你给一个变量（函数）赋值时：**
1. 声明：**编译器**询问**作用域**是否存在该变量，如没有，则进行声明
2. 查找：运行时**引擎**在**作用域**查找该变量，找到就给它赋值

**引擎查找类型分为 LHS 和 RHS：**
1. LHS：找到**变量容器**并进行**赋值**（非严格模式下找不到变量时会自动声明，否则抛出`ReferenceError`）
2. RHS：找到变量的**源值**（找不到时会抛出`ReferenceError`、查找到变量但是进行不合理的操作时会抛出`TypeError`）
```js
function foo(a) {
  console.log(a)   // RHS
}
foo(2)  // foo 使用了 RHS，2 是对变量 a 进行赋值所以使用的是 LHS
```

**作用域嵌套：**
1. 引擎无法在当前作用域查找到变量时，会向上一级继续查找，直到最外层的全局作用域

#### 作用域规则--词法作用域
**作用域的两种工作模型：**
1. 动态作用域：**运行**时确定，关注在何处**调用**（和JS中的this很像）
2. 词法作用域：**定义**时确定，关注在何处**声明**，只会查找一级标识符，如：`a.b.c`，只会查找`a`（JS所使用的）

**欺骗词法作用域的方法：**
1. `eval(...)`：非严格模式下：eval 所执行的代码如果**包含变量（函数）声明**，在运行时能**对词法作用域进行修改**，严格模式下 eval 有自己的作用域
2. `with(...)`：非严格模式下：通常被当作重复引用同一个对象中多个属性的快捷方式，实际是根据传递的对象**创建新的词法作用域**，严格模式下会被禁止
```js
function foo(str, a) {
  eval(str)          // 在执行时声明了 b
  console.log(a, b)  // 2 3
}
foo("var b = 3", 2)
```

**欺骗词法作用域导致的性能问题：**
1. 问题：引擎无法在编译时对作用域查找进行优化，导致代码运行变慢
2. 原因：有些依赖于对词法进行静态分析，预先确定变量函数定义的位置，以便快速找到标识符，但是如果发现`eval`和`with`，引擎只能假设标识符的位置判断都是无效的

#### 函数作用域和块作用域
**什么是函数作用域和块作用域：**
1. 函数作用域：有作用域气泡，这个函数的全部变量都可以在函数范围内使用及复用
2. 块作用域：ES6 中的`const`和`let`可声明块级作用域，在块`{}`范围内使用和复用，除此之外还有`try/catch`，`with`

**函数作用域可以用来做什么？**
1. 隐藏代码：把变量和函数包裹在一个函数作用域中，用这个作用域隐藏它们

**隐藏代码的好处：**
1. 规避冲突：避免同名标识符之间的冲突（规避冲突的两种解决方式：全局命名空间、模块管理工具）

**函数名本身会污染所在全局作用域，怎么解决？**
1. 使用立即执行函数表达式`(function foo() {..})()`，将变量名隐藏在自身中（此时`foo`只能在`...`处被访问），也称`IIFE`（也可以是匿名）

**区分函数声明和函数表达式：**
1. 函数声明：`function`是声明的第一个词，名称标识符绑定在所在作用域
2. 函数表达式：`function`不是声明的第一个词，名称标识符绑定在函数自身


#### 变量提升
1. 变量提升：即所有声明（变量和函数）被移动到各自作用域的最顶端（`const`和`let`不存在变量提升）
2. 提升顺序：函数会先提升，然后是变量
3. 存在同名声明时：如一个函数声明一个 var 声明，var 声明会被忽略掉，但是后续的函数声明能覆盖前面的

#### 闭包
1. 什么是闭包：当一个函数记住并访问所在词法作用域时就产生了闭包，即使函数是在当前词法作用域之外执行
2. 闭包的作用：保持对一个作用域的引用，使作用域一直存活
3. 回调函数与闭包：**定时器**、**事件监听器**、**Ajax请求**、**跨窗口通信**、**web workers**或其他异步（或同步任务）中，只要使用了回调函数，实际上就是在使用闭包
4. 模块与闭包：调用模块中的方法时，实际就是在使用闭包，没有闭包的模块不是真正的模块
5. 循环与闭包：循环过程中每个迭代都需要一个闭包作用域
```js
for(var i = 1; i < 4; i++) {
  setTimeout(() => {
    console.log(i)   // 4 4 4
  }, i*1000)
}

// 利用 IIFE 创建一个作用域，并创建一个变量用来保存每个迭代中的 i
for(var i = 1; i < 4; i++) {
  (function() {
    var j = i
    setTimeout(() => {
      console.log(j) // 1 2 3
    }, j*1000)
  })()
}

for(var i = 1; i < 4; i++) {
  (function(j) {
    setTimeout(() => {
      console.log(j) // 1 2 3
    }, j*1000)
  })(i)
}

// 给 setTimeout 传递第三个参数，定时器到期就传递给定时器中的函数
for(var i = 1; i < 4; i++) {
  setTimeout((j) => {
    console.log(j)  // 1 2 3
  }, i*1000, i)
}

// 使用 let 劫持作用域
for(var i = 1; i < 4; i++) {
  let j = i
  setTimeout(() => {
    console.log(j)  // 1 2 3
  }, j*1000)
}

for(let i = 1; i < 4; i++) {
  setTimeout(() => {
    console.log(i)  // 1 2 3
  }, i*1000)
}
```

### this和对象原型


### 类型和语法
我的另外几篇关于数据类型的博客：[数据类型介绍](https://nolaaaaa.github.io/2018/04/26/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/) [数据类型判断](https://nolaaaaa.github.io/2018/04/28/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/) [数据类型转换](https://nolaaaaa.github.io/2018/04/27/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)


### 异步和性能


### ES6及更新版本等内容
具体可参考阮一峰大大的 [ECMAScript入门](http://es6.ruanyifeng.com/)