---
title: 读书：你不知道的JS
date: 2019-08-31 20:44:10
tags: [JavaScript]
categories: 前端
---

【你不知道的JS】一共上中下三册，包含内容有：作用域和闭包、this和对象原型、类型和语法、异步和性能、ES6及更新版本等内容，整理本篇博客目的主要是整合所学基础知识
<escape><!-- more --></escape>

### 作用域和闭包
#### 引擎、编译器、作用域
**代码执行前的编译会经历的三个步骤：**
1. 词法分析：将字符组成的**字符串**分解成有意义的**代码块（词法单元）**，会有特定步骤进行性能优化
2. 语法分析：将**词法单元**转化成一个**抽象语法树（AST）**，会有特定步骤进行性能优化
3. 生成代码：将**AST**转化为**可执行代码**

**引擎、编译器、作用域的任务：**
1. 引擎：负责JS的编译、执行过程
2. 编译器：负责语法分析、代码生成
3. 作用域：收集维护变量、有一套严格的规则（如：词法作用域）

**当你给一个变量（函数）赋值时：**
1. 声明：**编译器**询问**作用域**是否存在该变量，如没有，则进行声明
2. 查找：运行时**引擎**在**作用域**查找该变量，找到就给它赋值

**引擎查找类型分为 LHS 和 RHS：**
1. LHS：找到**变量容器**并进行**赋值**（非严格模式下找不到变量时会自动声明，否则抛出 ReferenceError）
2. RHS：找到变量的**源值**（找不到时会抛出 ReferenceError、查找到变量但是进行不合理的操作时会抛出 TypeError）
```js
function foo(a) {
  console.log(a)   // RHS
}
foo(2)  // foo 使用了 RHS，2 是对变量 a 进行赋值所以使用的是 LHS
```

**作用域嵌套：**
1. 引擎无法在当前作用域查找到变量时，会向上一级继续查找，直到最外层的全局作用域

#### 作用域规则--词法作用域
**作用域的两种工作模型：**
1. 动态作用域：**运行**时确定，关注在何处**调用**（和JS中的this很像）
2. 词法作用域：**定义**时确定，关注在何处**声明**，只会查找一级标识符，如：`a.b.c`，只会查找 a（JS所使用的）

**欺骗词法作用域的方法：**
1. eval(...)：非严格模式下：eval 所执行的代码如果**包含变量（函数）声明**，在运行时能**对词法作用域进行修改**，严格模式下 eval 有自己的作用域
2. with(...)：非严格模式下：通常被当作重复引用同一个对象中多个属性的快捷方式，实际是根据传递的对象**创建新的词法作用域**，严格模式下会被禁止
```js
function foo(str, a) {
  eval(str)          // 在执行时声明了 b
  console.log(a, b)  // 2 3
}
foo("var b = 3", 2)
```

**欺骗词法作用域导致的性能问题：**
1. 问题：引擎无法在编译时对作用域查找进行优化，导致代码运行变慢
2. 原因：有些依赖于对词法进行静态分析，预先确定变量函数定义的位置，以便快速找到标识符，但是如果发现 eval 和 with，引擎只能假设标识符的位置判断都是无效的

#### 函数作用域和块作用域




### this和对象原型


### 类型和语法
我的另外几篇关于数据类型的博客：[数据类型介绍](https://nolaaaaa.github.io/2018/04/26/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/) [数据类型判断](https://nolaaaaa.github.io/2018/04/28/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/) [数据类型转换](https://nolaaaaa.github.io/2018/04/27/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/)


### 异步和性能


### ES6及更新版本等内容
具体可参考阮一峰大大的 [ECMAScript入门](http://es6.ruanyifeng.com/)