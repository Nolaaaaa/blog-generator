---
title: 前端基础知识整理
date: 2019-02-04 10:16:30
tags: JavaScript
categories: 前端
---

前端基础知识整理
<escape><!-- more --></escape>

## 1 HTML


## 2 CSS
### reset.css和normalize.css的区别
```js
npm i -S normalize.css
页面引用
import 'normalize.css'
```
reset.css和normalize.css的区别：
1. reset.css是强制性的，normalize.css是选择性的。
2. normalize修复了一些常见的PC端及移动端的bug，这往往超出了reset的能力范围
3. 在页面中调试样式的时候，如果使用了reset.css，在样式调试区域就会出现大量的继承属性链，但normalize.css并不会出现这个问题，因为它的样式规则使用的是具有针对性的样式及相对保守的使用多重选择器。

normalize.css的目标：
1. 保留有用的浏览器默认样式，而不是一概将它们“抹杀”。
2. normalize.css作用在范围更广的元素上面。
3. 修正了一些bug及主流浏览器在渲染上的不一致。
4. 提高了可用性。
5. 用更加详细的文档及注释来解释代码的含义。

### 替换元素和非替换元素
替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。如：`<img>` 、`<input>`、`<textarea> `、`<select>` 、`<object>` 都是替换元素。这些元素往往没有实际的内容，即是一个空元素。


## 3 JavaScript DOM JSON
### js实现持续动画效果
定时器
[window.requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)

### offsetWidth、clientWidth、scrollWidth、innerWidth、outerWidth区别
[获取宽高位置的方法](https://nolaaaaa.github.io/2018/09/23/%E8%8E%B7%E5%8F%96%E5%AE%BD%E9%AB%98%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/)

### DOM 标准事件模型是什么？哪些事件支持冒泡哪些不支持？
从技术上来说，W3C的DOM标准并不支持上述最原始的添加事件监听函数的方式，这些都是在DOM标准形成前的事件模型。尽管没有正式的W3C标准，但这种事件模型仍然得到广泛应用，这就是我们通常所说的0级DOM。
```js
<div id=”name” onclick="alert('Hello')" > </div>  
document.getElementById("name").onclick = function () {  
    alert("Hello");  
} 
```  

没有1级DOM。DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。
在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型。
```js
document.getElementById("myButton").addEventListener("click",
function (event) {
    alert("Button Click");
},true)
```
不支持冒泡：unload、load、resize、mouseleave、mouseenter、focus、error、blur、abort

### `JOSN`
**JSON** 是一种语法，用来序列化对象、数组、数值、字符串、布尔值和  [null](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)  。
JSON对象包含两个方法: 
1 `parse()` 方法：用于解析JSON字符串并返回对应的值。  [JavaScript Object Notation](http://json.org/) ( [JSON](https://developer.mozilla.org/en-US/docs/Glossary/JSON) 
2 `stringify()` 方法：将对象/值转换为 JSON 字符串的
除了这两个方法，JSON这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用。

### 函数和变量提升
函数和变量都会提升，函数声明提升先于变量提升
```js 
// 第一题，为什么打印出来的结果是1
var f=function(){
    console.log(1)
}
function f(){
    console.log(2)
}
f()   // 1
// 第二题，同上一题，把f()放在最开始为什么打印出来又是2
f()
var f=function(){
    console.log(1)
}
function f(){
    console.log(2)
}  // 2
// 第三题，为什么打印出来的结果是两个2
function f(){
    console.log(1)
}
f()
function f(){
    console.log(2)
}
f()  // 2  // 2   
```

### event对象中 target和currentTarget 属性的区别
`event.target`返回**触发事件**的元素，用户操作的元素
`event.currentTarget`返回**绑定事件**的元素，用户监听的元素

## 4 浏览器
### 几种主流内核
1. Trident（1997，IE，浏览器被弃用）
2. Gecko（2000，FireFox）、
3. Webkit（2001，Safari）
4. Presto（2003，opera前内核、已废弃）
5. Chromium（2008，Chrome前内核，基于webkit）
5. blink（2013，Chrome，Google 和 Opera Software 共同研发）
6. EdgeHTML（2015，Edge已重选Chromium作为内核）

### 浏览器内部结构组成？主要功能？
**浏览器结构组成**：
1. 用户界面（除了页面显示窗口之外的其他部分）
2. 浏览器引擎（负责通信，用户界面、渲染引擎之间传送指令，缓存中读写数据）
3. 渲染引擎（解析 HTML 和 CSS 并渲染）
4. 网络（网络调用或资源下载）
5. UI 后端（绘制基本的浏览器窗口内控件）
5. JS解释器（解释、编译、执行JS脚本）
5. 数据存储（保存 cookie、localStorage 等各种数据）

**渲染引擎的工作流程**：
1. 构建 DOM 树
2. 解析 CSS 文件，生成一个具有样式规则描述的 DOM 渲染树
3. 将渲染树进行布局、绘制
4. 如渲染完首屏后，对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的重新布局和重新绘制

ps：CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配，是为了节省效率，但是也要尽量避免在选择器末尾添加通配符。

**渲染引擎相关的性能优化**：
1. 减少 JS 加载对 Dom 渲染的影响
2. 避免重排，减少重绘（减少使用 width、 margin、 padding 等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替）
3. 减少使用关系型样式表的写法（使用唯一的类名、避免在选择器末尾添加通配符）
4. 减少 DOM 的层级

**浏览器的渲染进程**：
1. GUI渲染线程（渲染浏览器界面，与JS引擎线程是互斥）
2. JS引擎线程（处理Javascript脚本程序，与GUI引擎线程是互斥）
3. 事件触发线程（控制事件循环，待处理队列中的事件都得排队等待JS引擎处理）
4. 定时触发器线程（setInterval与setTimeout所在线程，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
5. 异步http请求线程（如有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行）

### 浏览器重绘和重排
**重排**(reflow) - 节点尺寸位置发生改变
**重绘**(repaint) - 样式发生改变
文档初次加载的时候，浏览器引擎会将HTML文档解析成对应的DOM树，紧接着会根据DOM元素的几何属性来构建一个用于渲染的的渲染树，渲染树的每个节点都包含其大小和内外边距等属性（对于隐藏的不需要显示的元素，不会构建到渲染树当中）。渲染树构建完成后，浏览器就可以将元素放置到正确位置了，再根据渲染树节点的样式属性绘制到页面当中。
更改元素的外观属性但是不影响到其布局的时候会引起重绘，例如修改其可见属性、修改其背景颜色和图片等。与重绘不同的是，更改元素的属性影响到其几何布局的时候就会引起重排，例如修改文字大小、修改内外边距等。对于浏览器来说，这两种情况都会影响到性能，重排影响更大，因为重排会影响到其父元素、子元素和兄弟元素的重排，而且重排是影响性能非常关键的几个因素之一。
哪些改变能引起重排:
1. 重新调整浏览器窗口大小
2. 添加、删除可见的DOM元素
3. 添加、删除样式表
4. 激活CSS伪类，如a:hover
5. 修改字体
6. 修改class的属性
7. 设置style的属性
8. 页面渲染器初始化
9. 计算offsetWidth和offsetHeight
10. display: none 隐藏一个 DOM 节点-触发重排和重绘
11. visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化

如何避免重排或者减少重排带来的性能问题:
1. 减少使用 width、 margin、 padding 等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替
2. 避免在内联样式中设置多重属性
3. 将动画应用在 absolute 定位或者 fixed 的元素上
4. 减少 table 布局
5. 批量修改 DOM
6. DOM离线化，即给元素设置`display:none`后进行操作不会频繁触发重排和重绘，只会在元素添加到元素中的时候触发一次
7. 缓存布局信息（将某个值缓存下来，避免重复读取）


### 浏览器缓存
浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：
先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；
区别是，强缓存不对发送请求到服务器，但协商缓存会。
当协商缓存也没命中时，服务器就会将资源发送回客户端。
当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；

### navigator.userAgent
`userAgent` 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。
```js
"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1"
```

### HTMLMediaElement.currentTime
属性会以秒为单位返回当前媒体元素的播放时间。设置这个属性会改变媒体元素当前播放位置。
可以做音乐播放拖拉进度条改变播放时间的部分


## 5 安全


## 6 框架
### Vue 双向绑定实现原理？
通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：
第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
1. 在自身实例化时往属性订阅器(dep)里面添加自己
2. 自身必须有一个update()方法
3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。
```js
<body>
  <div id="app">
    <input type="text" id="txt">
    <p id="show-txt"></p>
  </div>
  <script>
      var obj = {}
    Object.defineProperty(obj, 'txt', {
      get: function () {
        return obj
      },
      set: function (newValue) {
        document.getElementById('txt').value = newValue
        document.getElementById('show-txt').innerHTML = newValue
      }
    })
    document.addEventListener('keyup', function (e) {
      obj.txt = e.target.value
    })
  </script>
</body>
```

### Vue中的MVVM模式
[来源](https://www.jianshu.com/p/e54a9a34a773)
MVVM（Model-View-ViewModel）Vue自身将DOM和数据进行绑定，创建绑定后，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。

### v-show 和 v-if 的区别
v-show指令是通过修改元素的display **CSS** 属性让其显示或者隐藏
v-if指令是直接销毁和重建 **DOM** 达到让元素显示和隐藏的效果

### 让CSS只在当前组件中起作用
将当前组件的`<style>`修改为`<style scoped>`

### <keep-alive></keep-alive>的作用
`<keep-alive></keep-alive>` 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。

### 父子通信
父（组件上传出：`:data="data"`）传子（组件内接收：`props: ["items"]`）
子（组件内传出：`this.$emit("function")`）传父（组件上接收：`@function="function`）

### vuex

### 对Vue.js的template编译的理解？
简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
详情步骤：
首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）


### vue-router
#### 嵌套路由
通过 `children: []` 配置
例如：
```json
{ path: "/", redirect: "/home" },   // redirect 重定向开始页面 
{  
  path: "/home", component: home,  
  children: [  
    { path: "/home/other", component: other }  
  ]  
}
```  

### 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？


### vue-router有哪几种导航钩子？
beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave




## 7 前端工程化
## 前端优化
### 计算白屏和首屏时间
**白屏时间计算**
```html
<script type="text/javascript">
  // 不兼容performance.timing 的浏览器，如IE8
  window.pageStartTime = Date.now();
</script>
<script type="text/javascript">
  // 白屏时间结束点
  window.firstPaint = Date.now();
</script>
```
可使用 Performance API 时：firstPaint - performance.timing.navigationStart;
不可使用 Performance API 时：firstPaint - pageStartTime;

**首屏时间计算**
```html
<script type="text/javascript">
    window.firstScreen = Date.now();
</script>
```
首屏时间 = firstScreen - performance.timing.navigationStart


## 8 算法
### 算法的时间复杂度和空间复杂度
时间复杂度：指执行当前算法所消耗的时间
Ο(1)：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数
Ο(n)：一个循环（有变量n）
Ο(n2)：双重循环（有变量n）
Ο(logn)：有while的情况下（有变量n且i呈指数变化）
Ο(n3)：三重循环（有变量n）
Ο(nlogn)：一个循环+一个while（有变量n）

空间复杂度：指执行当前算法需要占用多少内存空间
O(1)：算法执行所需要的临时空间不随着某个变量n的大小而变化

参考自[时间复杂度和空间复杂度](https://zhuanlan.zhihu.com/p/50479555)