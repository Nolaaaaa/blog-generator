---
title: 前端基础知识整理
date: 2019-02-04 10:16:30
tags: JavaScript
categories: 前端
---

前端基础知识整理
<escape><!-- more --></escape>

## 1 HTML


## 2 CSS
### CSS预处理器—SASS
假设项目目录下有 css 和 scss 文件夹，运行以下命令会持续观察文件变化并即时编译
```js
//编译
npm run sass 'scss文件位置' 'css文件位置'
//本地安装的sass监听变化
node_modules/node-sass/bin/node-sass --watch 'scss文件位置' 'css文件位置'
node_modules/node-sass/bin/node-sass -wro css scss
```
但是每次运行的时候要输入那么长特别麻烦，需要手动配置环境
```json
//package.json中
 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1" ,
    "sass": "node_modules/node-sass/bin/node-sass -wro css scss" 
    /* 添加这一句后就可以直接在命令行输入 npm run sass监听了 */
  }
```

### reset.css和normalize.css的区别
```js
npm i -S normalize.css
页面引用
import 'normalize.css'
```
reset.css和normalize.css的区别：
1 reset.css是强制性的，normalize.css是选择性的。
2 normalize修复了一些常见的PC端及移动端的bug，这往往超出了reset的能力范围
3 在页面中调试样式的时候，如果使用了reset.css，在样式调试区域就会出现大量的继承属性链，但normalize.css并不会出现这个问题，因为它的样式规则使用的是具有针对性的样式及相对保守的使用多重选择器。

normalize.css的目标：
1 保留有用的浏览器默认样式，而不是一概将它们“抹杀”。
2 normalize.css作用在范围更广的元素上面。
3 修正了一些bug及主流浏览器在渲染上的不一致。
4 提高了可用性。
5 用更加详细的文档及注释来解释代码的含义。

### 替换元素和非替换元素
替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。如：`<img>` 、`<input>`、`<textarea> `、`<select>` 、`<object>` 都是替换元素。这些元素往往没有实际的内容，即是一个空元素。


## 3 JavaScript DOM JSON
### js实现持续动画效果
定时器
[window.requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)

### offsetWidth、clientWidth、scrollWidth、innerWidth、outerWidth区别
[获取宽高位置的方法](https://nolaaaaa.github.io/2018/09/23/%E8%8E%B7%E5%8F%96%E5%AE%BD%E9%AB%98%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/)

### DOM 标准事件模型是什么？哪些事件支持冒泡哪些不支持？
从技术上来说，W3C的DOM标准并不支持上述最原始的添加事件监听函数的方式，这些都是在DOM标准形成前的事件模型。尽管没有正式的W3C标准，但这种事件模型仍然得到广泛应用，这就是我们通常所说的0级DOM。
```js
<div id=”name” onclick="alert('Hello')" > </div>  
document.getElementById("name").onclick = function () {  
    alert("Hello");  
} 
```  

没有1级DOM。DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。
在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型。
```js
document.getElementById("myButton").addEventListener("click",
function (event) {
    alert("Button Click");
},true)
```
不支持冒泡：unload、load、resize、mouseleave、mouseenter、focus、error、blur、abort

### `JOSN`
**JSON** 是一种语法，用来序列化对象、数组、数值、字符串、布尔值和  [null](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)  。
JSON对象包含两个方法: 
1 `parse()` 方法：用于解析JSON字符串并返回对应的值。  [JavaScript Object Notation](http://json.org/) ( [JSON](https://developer.mozilla.org/en-US/docs/Glossary/JSON) 
2 `stringify()` 方法：将对象/值转换为 JSON 字符串的
除了这两个方法，JSON这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用。

### 函数和变量提升
函数和变量都会提升，函数声明提升先于变量提升
```js 
// 第一题，为什么打印出来的结果是1
var f=function(){
    console.log(1)
}
function f(){
    console.log(2)
}
f()   // 1
// 第二题，同上一题，把f()放在最开始为什么打印出来又是2
f()
var f=function(){
    console.log(1)
}
function f(){
    console.log(2)
}  // 2
// 第三题，为什么打印出来的结果是两个2
function f(){
    console.log(1)
}
f()
function f(){
    console.log(2)
}
f()  // 2  // 2   
```

### event对象中 target和currentTarget 属性的区别
`event.target`返回**触发事件**的元素，用户操作的元素
`event.currentTarget`返回**绑定事件**的元素，用户监听的元素

## 4 浏览器
### 浏览器重绘和重排
重排(reflow) - 浏览器构建渲染树完成时不包含位置和大小信息。计算元素位置和其他几何信息的过程称为重绘。
重绘(repaint) - 当布局结束后，浏览器遍历呈现树，调用呈现器的paint方法，将呈现器的内容显示在屏幕上。
文档初次加载的时候，浏览器引擎会将HTML文档解析成对应的DOM树，紧接着会根据DOM元素的几何属性来构建一个用于渲染的的渲染树，渲染树的每个节点都包含其大小和内外边距等属性（对于隐藏的不需要显示的元素，不会构建到渲染树当中）。渲染树构建完成后，浏览器就可以将元素放置到正确位置了，再根据渲染树节点的样式属性绘制到页面当中。
更改元素的外观属性但是不影响到其布局的时候会引起重绘，例如修改其可见属性、修改其背景颜色和图片等。与重绘不同的是，更改元素的属性影响到其几何布局的时候就会引起重排，例如修改文字大小、修改内外边距等。对于浏览器来说，这两种情况都会影响到性能，重排影响更大，因为重排会影响到其父元素、子元素和兄弟元素的重排，而且重排是影响性能非常关键的几个因素之一。
哪些改变能引起重排:
1 重新调整浏览器窗口大小
2 修改字体
3 添加、删除样式表
4 修改页面元素内容
5 激活CSS伪类，如a:hover
6 修改class的属性
7 修改DOM
8 计算offsetWidth和offsetHeight
9 设置style的属性
10 display: none 隐藏一个 DOM 节点-触发重排和重绘
11 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化

如何避免重排或者减少重排带来的性能问题:
1 修改元素的class属性，并且尽可能在DOM树中比较低的节点上
2 避免在内联样式中设置多重属性
3 将动画应用在absolute定位或者fixed的元素上
4 减少table布局
5 避免使用CSS表达式
6 元素重排会影响到其所有的子元素，也会影响到其父元素和兄弟元素，因此修改元素的属性会影响到重排的时候，尽可能的在一些DOM树中比较低的节点上修改。这样将其重排的影响范围降到最低。
7 我们都知道与DOM进行交互会非常影响性能，因此避免过多的进行DOM交互。同样，我们设置样式的时候，避免在内联样式中设置多重属性，因为每设置一个属性都会引起元素的重排，从而极大地影响性能。在需要设置多重属性的时候，我们可以把它封装成一个对象或者完整的class，然后一次性应用到元素当中去。从而将其对性能的影响降到最低。
8 将动画应用到fixed或者absolute的元素上，因为这不会影响到其他元素的布局，也就不会影响到其他元素的重排和重绘。因为他们只会引起自己的重排和重绘，因此极大地降低了对性能的损耗。
9 尽量减少table布局。过去为了对齐等原因，大部分的网页都用table布局，但是性能都非常差。table布局的重排和重绘，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。而且随便一个cell的高度宽度的修改都会影响到整个表格重排，因此性能非常差。所以，尽量避免使用table布局。
10 减少使用CSS表达式，因为每当文档重新加载或者部分文档重新加载的时候，CSS表达式都会重新计算一次，因此其性能会收到非常大的影响。


### 浏览器缓存
浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：
先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；
区别是，强缓存不对发送请求到服务器，但协商缓存会。
当协商缓存也没命中时，服务器就会将资源发送回客户端。
当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；

### navigator.userAgent
`userAgent` 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。
```js
"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1"
```

### HTMLMediaElement.currentTime
属性会以秒为单位返回当前媒体元素的播放时间。设置这个属性会改变媒体元素当前播放位置。
可以做音乐播放拖拉进度条改变播放时间的部分


## 5 安全


## 框架
### Vue 双向绑定实现原理？
通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：
第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。
```js
<body>
  <div id="app">
    <input type="text" id="txt">
    <p id="show-txt"></p>
  </div>
  <script>
      var obj = {}
    Object.defineProperty(obj, 'txt', {
      get: function () {
        return obj
      },
      set: function (newValue) {
        document.getElementById('txt').value = newValue
        document.getElementById('show-txt').innerHTML = newValue
      }
    })
    document.addEventListener('keyup', function (e) {
      obj.txt = e.target.value
    })
  </script>
</body>
```

### Vue中的MVVM模式
[来源](https://www.jianshu.com/p/e54a9a34a773)
MVVM（Model-View-ViewModel）Vue自身将DOM和数据进行绑定，创建绑定后，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。

### v-show 和 v-if 的区别
v-show指令是通过修改元素的display **CSS** 属性让其显示或者隐藏
v-if指令是直接销毁和重建 **DOM** 达到让元素显示和隐藏的效果

### 让CSS只在当前组件中起作用
将当前组件的`<style>`修改为`<style scoped>`

### <keep-alive></keep-alive>的作用
`<keep-alive></keep-alive>` 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。

### 父子通信
父（组件上传出：`:data="data"`）传子（组件内接收：`props: ["items"]`）
子（组件内传出：`this.$emit("function")`）传父（组件上接收：`@function="function`）

### vuex

### 对Vue.js的template编译的理解？
简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
详情步骤：
首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）


### vue-router
#### 嵌套路由
通过 `children: []` 配置
例如：
```json
{ path: "/", redirect: "/home" },   // redirect 重定向开始页面 
{  
  path: "/home", component: home,  
  children: [  
    { path: "/home/other", component: other }  
  ]  
}
```  

### 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？


### vue-router有哪几种导航钩子？
beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave




## 6 前端工程化


## 前端优化
### 计算白屏和首屏时间
**白屏时间计算**
```html
<script type="text/javascript">
  // 不兼容performance.timing 的浏览器，如IE8
  window.pageStartTime = Date.now();
</script>
<script type="text/javascript">
  // 白屏时间结束点
  window.firstPaint = Date.now();
</script>
```
可使用 Performance API 时：firstPaint - performance.timing.navigationStart;
不可使用 Performance API 时：firstPaint - pageStartTime;

**首屏时间计算**
```html
<script type="text/javascript">
    window.firstScreen = Date.now();
</script>
```
首屏时间 = firstScreen - performance.timing.navigationStart


## 7 算法
### 算法的时间复杂度和空间复杂度
时间复杂度：指执行当前算法所消耗的时间
Ο(1)：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数
Ο(n)：一个循环（有变量n）
Ο(n2)：双重循环（有变量n）
Ο(logn)：有while的情况下（有变量n且i呈指数变化）
Ο(n3)：三重循环（有变量n）
Ο(nlogn)：一个循环+一个while（有变量n）

空间复杂度：指执行当前算法需要占用多少内存空间
O(1)：算法执行所需要的临时空间不随着某个变量n的大小而变化

参考自[时间复杂度和空间复杂度](https://zhuanlan.zhihu.com/p/50479555)